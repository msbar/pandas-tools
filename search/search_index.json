{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pypdtools","text":"<p>pypdtools is a Python package that extends the functionality of Pandas DataFrames by introducing the <code>PtDataFrame</code> class. <code>PtDataFrame</code> provides additional features and enhancements to work with DataFrames in a more convenient and flexible way.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Asynchronous iteration support: <code>PtDataFrame</code> implements both synchronous and asynchronous iterators, allowing for efficient and convenient data processing in asynchronous contexts.</li> <li>Context manager support: <code>PtDataFrame</code> can be used as a context manager to easily access the encapsulated Pandas DataFrame.</li> <li>Concatenation and reduction: <code>PtDataFrame</code> supports concatenation of multiple instances and reduction of a list of <code>PtDataFrame</code> objects into a single instance.</li> <li>Column extraction: Easily extract a column as a list from a <code>PtDataFrame</code>.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install pypdtools using pip: <pre><code>pip install pypdtools\n</code></pre></p>"},{"location":"abc/dataframe/","title":"dataframe","text":""},{"location":"abc/dataframe/#pypdtools.abc.dataframe.AbstractPtDataFrame","title":"<code>AbstractPtDataFrame</code>","text":"<p>         Bases: <code>ABC</code>, <code>AsyncIterator</code>, <code>Awaitable</code>, <code>Sized</code>, <code>Iterator</code></p> <p>Abstract base class for DataFrame objects.</p> Source code in <code>pypdtools\\abc\\dataframe.py</code> <pre><code>class AbstractPtDataFrame(ABC, AsyncIterator, Awaitable, Sized, Iterator):\n\"\"\"Abstract base class for DataFrame objects.\"\"\"\n@abstractmethod\ndef __repr__(self):\n...\n@abstractmethod\ndef __str__(self):\n...\n@abstractmethod\ndef __enter__(self):\n...\n@abstractmethod\nasync def __aenter__(self):\n...\n@abstractmethod\ndef __exit__(self, exc_type, exc_val, exc_tb):\n...\n@abstractmethod\nasync def __aexit__(self, exc_type, exc_val, exc_tb):\n...\n</code></pre>"},{"location":"core/dataframe/","title":"dataframe","text":""},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame","title":"<code>PtDataFrame</code>","text":"<p>         Bases: <code>AbstractPtDataFrame</code></p> <p>A class representing a Pandas DataFrame with additional functionality.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.</p> <code>pd.DataFrame()</code> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>class PtDataFrame(AbstractPtDataFrame):\n\"\"\"\n    A class representing a Pandas DataFrame with additional functionality.\n    Args:\n        df (pd.DataFrame, optional): The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.\n    \"\"\"\ndef __init__(self, df: pd.DataFrame = pd.DataFrame()) -&gt; None:\n\"\"\"\n        Initialize the PtDataFrame.\n        Args:\n            df (pd.DataFrame, optional): The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.\n        \"\"\"\nself._df = df\nself._iterator = self._df.itertuples(index=False)\nself._lock = Lock()\n@property\ndef df(self) -&gt; pd.DataFrame:\n\"\"\"\n        Get the encapsulated Pandas DataFrame.\n        Returns:\n            pd.DataFrame: The encapsulated Pandas DataFrame.\n        \"\"\"\nreturn self._df\ndef __repr__(self) -&gt; str:\n\"\"\"\n        Return a string representation of the PtDataFrame.\n        Returns:\n            str: A string representation of the PtDataFrame.\n        \"\"\"\nreturn self._df.__repr__()\ndef __str__(self) -&gt; str:\n\"\"\"\n        Return a string representation of the PtDataFrame.\n        Returns:\n            str: A string representation of the PtDataFrame.\n        \"\"\"\nreturn self._df.__str__()\ndef __await__(self) -&gt; Awaitable:\n\"\"\"\n        Awaitable support for the PtDataFrame.\n        Returns:\n            Awaitable: An awaitable object.\n        \"\"\"\nreturn sleep(0.0001).__await__()\ndef __enter__(self) -&gt; pd.DataFrame:\n\"\"\"\n        Enter the context manager and return the encapsulated Pandas DataFrame.\n        Returns:\n            pd.DataFrame: The encapsulated Pandas DataFrame.\n        \"\"\"\nreturn self._df\nasync def __aenter__(self) -&gt; pd.DataFrame:\n\"\"\"\n        Asynchronous version of __enter__(). Enter the context manager and return the encapsulated Pandas DataFrame.\n        Returns:\n            pd.DataFrame: The encapsulated Pandas DataFrame.\n        \"\"\"\nreturn self._df\ndef __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n\"\"\"\n        Exit the context manager.\n        Args:\n            exc_type (type): The exception type, if any.\n            exc_val (Exception): The exception instance, if any.\n            exc_tb (traceback): The traceback, if any.\n        \"\"\"\nreturn None\nasync def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n\"\"\"\n        Asynchronous version of __exit__(). Exit the context manager.\n        Args:\n            exc_type (type): The exception type, if any.\n            exc_val (Exception): The exception instance, if any.\n            exc_tb (traceback): The traceback, if any.\n        \"\"\"\nreturn None\ndef __aiter__(self) -&gt; Iterator:\n\"\"\"\n        Asynchronous iterator support for the PtDataFrame.\n        Returns:\n            Iterator: An asynchronous iterator.\n        \"\"\"\nself._iterator = self._df.itertuples(index=False)\nasync def _aiter() -&gt; Iterator:\n\"\"\"\n            Asynchronous iterator helper function.\n            Yields:\n                Iterator: An item from the PtDataFrame.\n            \"\"\"\nwhile True:\ntry:\nyield self._iterator.__next__()\nexcept StopIteration:\nbreak\nreturn _aiter()\ndef __iter__(self) -&gt; Iterator:\n\"\"\"\n               Iterator\n        support for the PtDataFrame.\n               Returns:\n                   Iterator: An iterator.\n        \"\"\"\nself._iterator = self._df.itertuples(index=False)\nreturn (it for it in self._iterator)\ndef __len__(self) -&gt; int:\n\"\"\"\n        Return the length of the PtDataFrame.\n        Returns:\n            int: The length of the PtDataFrame.\n        \"\"\"\nreturn len(self._df)\nasync def __anext__(self) -&gt; Awaitable:\n\"\"\"\n        Asynchronous iterator support for the PtDataFrame.\n        Returns:\n            Awaitable: An awaitable object.\n        \"\"\"\nasync with self._lock:\ntry:\nreturn self._iterator.__next__()\nexcept StopIteration:\nraise StopAsyncIteration\ndef __next__(self) -&gt; Any:\n\"\"\"\n        Iterator support for the PtDataFrame.\n        Returns:\n            Any: An item from the PtDataFrame.\n        \"\"\"\nreturn self._iterator.__next__()\ndef __add__(self, other) -&gt; \"PtDataFrame\":\n\"\"\"\n        Concatenate the PtDataFrame with another PtDataFrame.\n        Args:\n            other (PtDataFrame): The PtDataFrame to concatenate.\n        Returns:\n            PtDataFrame: The concatenated PtDataFrame.\n        \"\"\"\nconcat = pd.concat([self._df, other._df], ignore_index=True)\nreturn PtDataFrame(concat)\ndef __iadd__(self, other) -&gt; \"PtDataFrame\":\n\"\"\"\n        In-place concatenation of the PtDataFrame with another PtDataFrame.\n        Args:\n            other (PtDataFrame): The PtDataFrame to concatenate.\n        Returns:\n            PtDataFrame: The concatenated PtDataFrame.\n        \"\"\"\nself._df = pd.concat([self._df, other._df], ignore_index=True)\nreturn self\n@classmethod\ndef reduce(cls, df_list) -&gt; \"PtDataFrame\":\n\"\"\"\n        Reduce a list of PtDataFrame objects into a single PtDataFrame.\n        Args:\n            df_list (List[PtDataFrame]): The list of PtDataFrame objects to reduce.\n        Returns:\n            PtDataFrame: The reduced PtDataFrame.\n        \"\"\"\nreturn PtDataFrame(reduce(lambda x, y: x + y, df_list).df)\ndef col_to_list(self, col_name, drop_duplicates=True) -&gt; List:\n\"\"\"\n        Extract a column as a list from the PtDataFrame.\n        Args:\n            col_name (str): The name of the column to extract.\n            drop_duplicates (bool, optional): Whether to drop duplicate values. Defaults to True.\n        Returns:\n            List: The column values as a list.\n        \"\"\"\nif drop_duplicates:\nreturn self._df[col_name].drop_duplicates().tolist()\nreturn self._df[col_name].tolist()\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.df","title":"<code>df: pd.DataFrame</code>  <code>property</code>","text":"<p>Get the encapsulated Pandas DataFrame.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: The encapsulated Pandas DataFrame.</p>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Concatenate the PtDataFrame with another PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PtDataFrame</code> <p>The PtDataFrame to concatenate.</p> required <p>Returns:</p> Name Type Description <code>PtDataFrame</code> <code>PtDataFrame</code> <p>The concatenated PtDataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __add__(self, other) -&gt; \"PtDataFrame\":\n\"\"\"\n    Concatenate the PtDataFrame with another PtDataFrame.\n    Args:\n        other (PtDataFrame): The PtDataFrame to concatenate.\n    Returns:\n        PtDataFrame: The concatenated PtDataFrame.\n    \"\"\"\nconcat = pd.concat([self._df, other._df], ignore_index=True)\nreturn PtDataFrame(concat)\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Asynchronous version of enter(). Enter the context manager and return the encapsulated Pandas DataFrame.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: The encapsulated Pandas DataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>async def __aenter__(self) -&gt; pd.DataFrame:\n\"\"\"\n    Asynchronous version of __enter__(). Enter the context manager and return the encapsulated Pandas DataFrame.\n    Returns:\n        pd.DataFrame: The encapsulated Pandas DataFrame.\n    \"\"\"\nreturn self._df\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Asynchronous version of exit(). Exit the context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>The exception type, if any.</p> required <code>exc_val</code> <code>Exception</code> <p>The exception instance, if any.</p> required <code>exc_tb</code> <code>traceback</code> <p>The traceback, if any.</p> required Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n\"\"\"\n    Asynchronous version of __exit__(). Exit the context manager.\n    Args:\n        exc_type (type): The exception type, if any.\n        exc_val (Exception): The exception instance, if any.\n        exc_tb (traceback): The traceback, if any.\n    \"\"\"\nreturn None\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__aiter__","title":"<code>__aiter__()</code>","text":"<p>Asynchronous iterator support for the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An asynchronous iterator.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __aiter__(self) -&gt; Iterator:\n\"\"\"\n    Asynchronous iterator support for the PtDataFrame.\n    Returns:\n        Iterator: An asynchronous iterator.\n    \"\"\"\nself._iterator = self._df.itertuples(index=False)\nasync def _aiter() -&gt; Iterator:\n\"\"\"\n        Asynchronous iterator helper function.\n        Yields:\n            Iterator: An item from the PtDataFrame.\n        \"\"\"\nwhile True:\ntry:\nyield self._iterator.__next__()\nexcept StopIteration:\nbreak\nreturn _aiter()\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Asynchronous iterator support for the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>Awaitable</code> <code>Awaitable</code> <p>An awaitable object.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>async def __anext__(self) -&gt; Awaitable:\n\"\"\"\n    Asynchronous iterator support for the PtDataFrame.\n    Returns:\n        Awaitable: An awaitable object.\n    \"\"\"\nasync with self._lock:\ntry:\nreturn self._iterator.__next__()\nexcept StopIteration:\nraise StopAsyncIteration\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__await__","title":"<code>__await__()</code>","text":"<p>Awaitable support for the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>Awaitable</code> <code>Awaitable</code> <p>An awaitable object.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __await__(self) -&gt; Awaitable:\n\"\"\"\n    Awaitable support for the PtDataFrame.\n    Returns:\n        Awaitable: An awaitable object.\n    \"\"\"\nreturn sleep(0.0001).__await__()\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager and return the encapsulated Pandas DataFrame.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: The encapsulated Pandas DataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __enter__(self) -&gt; pd.DataFrame:\n\"\"\"\n    Enter the context manager and return the encapsulated Pandas DataFrame.\n    Returns:\n        pd.DataFrame: The encapsulated Pandas DataFrame.\n    \"\"\"\nreturn self._df\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>The exception type, if any.</p> required <code>exc_val</code> <code>Exception</code> <p>The exception instance, if any.</p> required <code>exc_tb</code> <code>traceback</code> <p>The traceback, if any.</p> required Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n\"\"\"\n    Exit the context manager.\n    Args:\n        exc_type (type): The exception type, if any.\n        exc_val (Exception): The exception instance, if any.\n        exc_tb (traceback): The traceback, if any.\n    \"\"\"\nreturn None\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>In-place concatenation of the PtDataFrame with another PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PtDataFrame</code> <p>The PtDataFrame to concatenate.</p> required <p>Returns:</p> Name Type Description <code>PtDataFrame</code> <code>PtDataFrame</code> <p>The concatenated PtDataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __iadd__(self, other) -&gt; \"PtDataFrame\":\n\"\"\"\n    In-place concatenation of the PtDataFrame with another PtDataFrame.\n    Args:\n        other (PtDataFrame): The PtDataFrame to concatenate.\n    Returns:\n        PtDataFrame: The concatenated PtDataFrame.\n    \"\"\"\nself._df = pd.concat([self._df, other._df], ignore_index=True)\nreturn self\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__init__","title":"<code>__init__(df=pd.DataFrame())</code>","text":"<p>Initialize the PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.</p> <code>pd.DataFrame()</code> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __init__(self, df: pd.DataFrame = pd.DataFrame()) -&gt; None:\n\"\"\"\n    Initialize the PtDataFrame.\n    Args:\n        df (pd.DataFrame, optional): The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.\n    \"\"\"\nself._df = df\nself._iterator = self._df.itertuples(index=False)\nself._lock = Lock()\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__iter__","title":"<code>__iter__()</code>","text":"<pre><code>   Iterator\n</code></pre> <p>support for the PtDataFrame.</p> <pre><code>   Returns:\n       Iterator: An iterator.\n</code></pre> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __iter__(self) -&gt; Iterator:\n\"\"\"\n           Iterator\n    support for the PtDataFrame.\n           Returns:\n               Iterator: An iterator.\n    \"\"\"\nself._iterator = self._df.itertuples(index=False)\nreturn (it for it in self._iterator)\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the PtDataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Return the length of the PtDataFrame.\n    Returns:\n        int: The length of the PtDataFrame.\n    \"\"\"\nreturn len(self._df)\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__next__","title":"<code>__next__()</code>","text":"<p>Iterator support for the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>An item from the PtDataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __next__(self) -&gt; Any:\n\"\"\"\n    Iterator support for the PtDataFrame.\n    Returns:\n        Any: An item from the PtDataFrame.\n    \"\"\"\nreturn self._iterator.__next__()\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PtDataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Return a string representation of the PtDataFrame.\n    Returns:\n        str: A string representation of the PtDataFrame.\n    \"\"\"\nreturn self._df.__repr__()\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PtDataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Return a string representation of the PtDataFrame.\n    Returns:\n        str: A string representation of the PtDataFrame.\n    \"\"\"\nreturn self._df.__str__()\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.col_to_list","title":"<code>col_to_list(col_name, drop_duplicates=True)</code>","text":"<p>Extract a column as a list from the PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>The name of the column to extract.</p> required <code>drop_duplicates</code> <code>bool</code> <p>Whether to drop duplicate values. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>The column values as a list.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>def col_to_list(self, col_name, drop_duplicates=True) -&gt; List:\n\"\"\"\n    Extract a column as a list from the PtDataFrame.\n    Args:\n        col_name (str): The name of the column to extract.\n        drop_duplicates (bool, optional): Whether to drop duplicate values. Defaults to True.\n    Returns:\n        List: The column values as a list.\n    \"\"\"\nif drop_duplicates:\nreturn self._df[col_name].drop_duplicates().tolist()\nreturn self._df[col_name].tolist()\n</code></pre>"},{"location":"core/dataframe/#pypdtools.core.dataframe.PtDataFrame.reduce","title":"<code>reduce(df_list)</code>  <code>classmethod</code>","text":"<p>Reduce a list of PtDataFrame objects into a single PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df_list</code> <code>List[PtDataFrame]</code> <p>The list of PtDataFrame objects to reduce.</p> required <p>Returns:</p> Name Type Description <code>PtDataFrame</code> <code>PtDataFrame</code> <p>The reduced PtDataFrame.</p> Source code in <code>pypdtools\\core\\dataframe.py</code> <pre><code>@classmethod\ndef reduce(cls, df_list) -&gt; \"PtDataFrame\":\n\"\"\"\n    Reduce a list of PtDataFrame objects into a single PtDataFrame.\n    Args:\n        df_list (List[PtDataFrame]): The list of PtDataFrame objects to reduce.\n    Returns:\n        PtDataFrame: The reduced PtDataFrame.\n    \"\"\"\nreturn PtDataFrame(reduce(lambda x, y: x + y, df_list).df)\n</code></pre>"},{"location":"core/scripts/","title":"scripts","text":""},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl","title":"<code>BaseEtl</code>","text":"<p>         Bases: <code>AbstractEtl</code></p> <p>This class is used to create an ETL object.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>class BaseEtl(AbstractEtl):\n\"\"\"This class is used to create an ETL object.\"\"\"\ndef __init__(self) -&gt; None:\n\"\"\"This method is used to initialize the ETL object.\"\"\"\nsuper().__init__()\nself.data = None\nself.executed = False\ndef extract(self):\n\"\"\"This method is used to get data from the source.\"\"\"\nraise NotImplementedError\ndef transform(self):\n\"\"\"This method is used to transform the data.\"\"\"\nraise NotImplementedError\ndef load(self):\n\"\"\"This method is used to load the data.\"\"\"\nraise NotImplementedError\ndef execute(self):\n\"\"\"This method is used to execute the etl.\"\"\"\nif self.executed:\nreturn self\nself.extract()\nself.transform()\nself.load()\nself.executed = True\nreturn self\n@property\ndef data(self) -&gt; pd.DataFrame:\n\"\"\"This method is used to get the data.\"\"\"\nself.execute()\nreturn self._df\ndef __len__(self) -&gt; int:\n\"\"\"This method is used to get the length of the data.\"\"\"\nself.execute()\nreturn super().__len__()\ndef __iter__(self) -&gt; Iterator:\n\"\"\"This method is used to iterate over the data.\"\"\"\nself.execute()\nreturn super().__iter__()\ndef __aiter__(self) -&gt; Iterator:\n\"\"\"This method is used to async iterate over the data.\"\"\"\nself.execute()\nreturn super().__aiter__()\ndef __enter__(self) -&gt; pd.DataFrame:\n\"\"\"This method is used to enter the context.\"\"\"\nself.execute()\nreturn super().__enter__()\nasync def __aenter__(self) -&gt; pd.DataFrame:\n\"\"\"This method is used to async enter the context.\"\"\"\nself.execute()\nreturn super().__aenter__()\ndef __add__(self, other) -&gt; PtDataFrame:\n\"\"\"This method is used to add two dataframes.\"\"\"\nself.execute()\nother.execute()\nreturn super().__add__(other)\ndef __radd__(self, other) -&gt; PtDataFrame:\n\"\"\"This method is used to add two dataframes.\"\"\"\nself.execute()\nother.execute()\nreturn super().__radd__(other)\ndef col_to_list(self, col_name, drop_duplicates=True) -&gt; List:\n\"\"\"This method is used to get a column as a list.\"\"\"\nself.execute()\nreturn super().col_to_list(col_name, drop_duplicates)\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.data","title":"<code>data: pd.DataFrame</code>  <code>property</code>","text":"<p>This method is used to get the data.</p>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.__add__","title":"<code>__add__(other)</code>","text":"<p>This method is used to add two dataframes.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def __add__(self, other) -&gt; PtDataFrame:\n\"\"\"This method is used to add two dataframes.\"\"\"\nself.execute()\nother.execute()\nreturn super().__add__(other)\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>This method is used to async enter the context.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>async def __aenter__(self) -&gt; pd.DataFrame:\n\"\"\"This method is used to async enter the context.\"\"\"\nself.execute()\nreturn super().__aenter__()\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.__aiter__","title":"<code>__aiter__()</code>","text":"<p>This method is used to async iterate over the data.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def __aiter__(self) -&gt; Iterator:\n\"\"\"This method is used to async iterate over the data.\"\"\"\nself.execute()\nreturn super().__aiter__()\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.__enter__","title":"<code>__enter__()</code>","text":"<p>This method is used to enter the context.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def __enter__(self) -&gt; pd.DataFrame:\n\"\"\"This method is used to enter the context.\"\"\"\nself.execute()\nreturn super().__enter__()\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.__init__","title":"<code>__init__()</code>","text":"<p>This method is used to initialize the ETL object.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"This method is used to initialize the ETL object.\"\"\"\nsuper().__init__()\nself.data = None\nself.executed = False\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.__iter__","title":"<code>__iter__()</code>","text":"<p>This method is used to iterate over the data.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def __iter__(self) -&gt; Iterator:\n\"\"\"This method is used to iterate over the data.\"\"\"\nself.execute()\nreturn super().__iter__()\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.__len__","title":"<code>__len__()</code>","text":"<p>This method is used to get the length of the data.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"This method is used to get the length of the data.\"\"\"\nself.execute()\nreturn super().__len__()\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.__radd__","title":"<code>__radd__(other)</code>","text":"<p>This method is used to add two dataframes.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def __radd__(self, other) -&gt; PtDataFrame:\n\"\"\"This method is used to add two dataframes.\"\"\"\nself.execute()\nother.execute()\nreturn super().__radd__(other)\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.col_to_list","title":"<code>col_to_list(col_name, drop_duplicates=True)</code>","text":"<p>This method is used to get a column as a list.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def col_to_list(self, col_name, drop_duplicates=True) -&gt; List:\n\"\"\"This method is used to get a column as a list.\"\"\"\nself.execute()\nreturn super().col_to_list(col_name, drop_duplicates)\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.execute","title":"<code>execute()</code>","text":"<p>This method is used to execute the etl.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def execute(self):\n\"\"\"This method is used to execute the etl.\"\"\"\nif self.executed:\nreturn self\nself.extract()\nself.transform()\nself.load()\nself.executed = True\nreturn self\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.extract","title":"<code>extract()</code>","text":"<p>This method is used to get data from the source.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def extract(self):\n\"\"\"This method is used to get data from the source.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.load","title":"<code>load()</code>","text":"<p>This method is used to load the data.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def load(self):\n\"\"\"This method is used to load the data.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"core/scripts/#pypdtools.core.scripts.BaseEtl.transform","title":"<code>transform()</code>","text":"<p>This method is used to transform the data.</p> Source code in <code>pypdtools\\core\\scripts.py</code> <pre><code>def transform(self):\n\"\"\"This method is used to transform the data.\"\"\"\nraise NotImplementedError\n</code></pre>"},{"location":"getting_started/quickstart/","title":"Quick Start","text":""},{"location":"getting_started/quickstart/#usage","title":"Usage","text":"<p>Here's an example of how to use the <code>PtDataFrame</code> class:</p> <pre><code>import pandas as pd\nfrom pypdtools.core.dataframe import PtDataFrame\n# Create a Pandas DataFrame\ndata = {\n\"a\": [1, 2, 3],\n\"b\": [4, 5, 6],\n\"c\": [7, 8, 9]\n}\ndf = pd.DataFrame(data)\n# Create a PtDataFrame from the Pandas DataFrame\npt_df = PtDataFrame(df)\n# Async Iterate over rows\nasync for row in pt_df:\nprint(row)\n# Concatenate PtDataFrames\npt_df2 = PtDataFrame(df)\nconcatenated = pt_df + pt_df2\n# Reduce a list of PtDataFrames\npt_df3 = PtDataFrame.reduce([pt_df, pt_df2])\n# Extract a column as a list\ncol_values = pt_df.col_to_list(\"a\")\nprint(col_values)\n</code></pre>"},{"location":"utils/asyncs/","title":"asyncs","text":""},{"location":"utils/asyncs/#pypdtools.utils.asyncs.AsyncCollection","title":"<code>AsyncCollection</code>","text":"<p>A class that allows for asynchronous iteration over a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>iterable</code> <p>The collection to iterate over.</p> required <p>Attributes:</p> Name Type Description <code>collection</code> <code>iterable</code> <p>The collection to iterate over.</p> Source code in <code>pypdtools\\utils\\asyncs.py</code> <pre><code>class AsyncCollection:\n\"\"\"A class that allows for asynchronous iteration over a collection.\n    Args:\n        collection (iterable): The collection to iterate over.\n    Attributes:\n        collection (iterable): The collection to iterate over.\n    \"\"\"\ndef __init__(self, collection):\nself.collection = collection\nasync def __aiter__(self) -&gt; Iterator:\n\"\"\"Asynchronously iterate over the collection.\n        Yields:\n            Any: The next item in the collection.\n        \"\"\"\nfor item in self.collection:\nyield item\nawait asyncio.sleep(0)\nasync def __anext__(self) -&gt; Awaitable:\n\"\"\"Asynchronously get the next item in the collection.\n        Raises:\n            StopAsyncIteration: If there are no more items in the collection.\n        Returns:\n            Any: The next item in the collection.\n        \"\"\"\ntry:\nitem = next(self.iterator)\nexcept StopIteration:\nraise StopAsyncIteration\nelse:\nawait asyncio.sleep(0)\nreturn item\nasync def __aenter__(self) -&gt; \"AsyncCollection\":\n\"\"\"Enter the async context.\n        Returns:\n            AsyncCollection: This object.\n        \"\"\"\nreturn self\nasync def __aexit__(self, exc_type, exc, tb):\n\"\"\"Exit the async context.\n        Args:\n            exc_type (type): The type of the exception (if any).\n            exc (Exception): The exception instance (if any).\n            tb (traceback): The traceback object (if any).\n        \"\"\"\npass\nasync def map(self, func) -&gt; List:\n\"\"\"Asynchronously apply a function to each item in the collection.\n        Args:\n            func (callable): The function to apply.\n        Returns:\n            List: A list of the results of applying the function to each item in the collection.\n        \"\"\"\ntasks = []\nfor item in self.collection:\ntasks.append(asyncio.ensure_future(func(item)))\nresults = await asyncio.gather(*tasks)\nreturn results\n</code></pre>"},{"location":"utils/asyncs/#pypdtools.utils.asyncs.AsyncCollection.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the async context.</p> <p>Returns:</p> Name Type Description <code>AsyncCollection</code> <code>AsyncCollection</code> <p>This object.</p> Source code in <code>pypdtools\\utils\\asyncs.py</code> <pre><code>async def __aenter__(self) -&gt; \"AsyncCollection\":\n\"\"\"Enter the async context.\n    Returns:\n        AsyncCollection: This object.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"utils/asyncs/#pypdtools.utils.asyncs.AsyncCollection.__aexit__","title":"<code>__aexit__(exc_type, exc, tb)</code>  <code>async</code>","text":"<p>Exit the async context.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>The type of the exception (if any).</p> required <code>exc</code> <code>Exception</code> <p>The exception instance (if any).</p> required <code>tb</code> <code>traceback</code> <p>The traceback object (if any).</p> required Source code in <code>pypdtools\\utils\\asyncs.py</code> <pre><code>async def __aexit__(self, exc_type, exc, tb):\n\"\"\"Exit the async context.\n    Args:\n        exc_type (type): The type of the exception (if any).\n        exc (Exception): The exception instance (if any).\n        tb (traceback): The traceback object (if any).\n    \"\"\"\npass\n</code></pre>"},{"location":"utils/asyncs/#pypdtools.utils.asyncs.AsyncCollection.__aiter__","title":"<code>__aiter__()</code>  <code>async</code>","text":"<p>Asynchronously iterate over the collection.</p> <p>Yields:</p> Name Type Description <code>Any</code> <code>Iterator</code> <p>The next item in the collection.</p> Source code in <code>pypdtools\\utils\\asyncs.py</code> <pre><code>async def __aiter__(self) -&gt; Iterator:\n\"\"\"Asynchronously iterate over the collection.\n    Yields:\n        Any: The next item in the collection.\n    \"\"\"\nfor item in self.collection:\nyield item\nawait asyncio.sleep(0)\n</code></pre>"},{"location":"utils/asyncs/#pypdtools.utils.asyncs.AsyncCollection.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Asynchronously get the next item in the collection.</p> <p>Raises:</p> Type Description <code>StopAsyncIteration</code> <p>If there are no more items in the collection.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Awaitable</code> <p>The next item in the collection.</p> Source code in <code>pypdtools\\utils\\asyncs.py</code> <pre><code>async def __anext__(self) -&gt; Awaitable:\n\"\"\"Asynchronously get the next item in the collection.\n    Raises:\n        StopAsyncIteration: If there are no more items in the collection.\n    Returns:\n        Any: The next item in the collection.\n    \"\"\"\ntry:\nitem = next(self.iterator)\nexcept StopIteration:\nraise StopAsyncIteration\nelse:\nawait asyncio.sleep(0)\nreturn item\n</code></pre>"},{"location":"utils/asyncs/#pypdtools.utils.asyncs.AsyncCollection.map","title":"<code>map(func)</code>  <code>async</code>","text":"<p>Asynchronously apply a function to each item in the collection.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to apply.</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>A list of the results of applying the function to each item in the collection.</p> Source code in <code>pypdtools\\utils\\asyncs.py</code> <pre><code>async def map(self, func) -&gt; List:\n\"\"\"Asynchronously apply a function to each item in the collection.\n    Args:\n        func (callable): The function to apply.\n    Returns:\n        List: A list of the results of applying the function to each item in the collection.\n    \"\"\"\ntasks = []\nfor item in self.collection:\ntasks.append(asyncio.ensure_future(func(item)))\nresults = await asyncio.gather(*tasks)\nreturn results\n</code></pre>"}]}