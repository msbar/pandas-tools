{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pandas Tools","text":"<p>PandasTools is a Python package that extends the functionality of Pandas DataFrames by introducing the <code>PtDataFrame</code> class. <code>PtDataFrame</code> provides additional features and enhancements to work with DataFrames in a more convenient and flexible way.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Asynchronous iteration support: <code>PtDataFrame</code> implements both synchronous and asynchronous iterators, allowing for efficient and convenient data processing in asynchronous contexts.</li> <li>Context manager support: <code>PtDataFrame</code> can be used as a context manager to easily access the encapsulated Pandas DataFrame.</li> <li>Concatenation and reduction: <code>PtDataFrame</code> supports concatenation of multiple instances and reduction of a list of <code>PtDataFrame</code> objects into a single instance.</li> <li>Column extraction: Easily extract a column as a list from a <code>PtDataFrame</code>.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install PandasTools using pip: <pre><code>pip install pandas-tools\n</code></pre></p>"},{"location":"abc/abstracts/","title":"abstracts","text":""},{"location":"abc/abstracts/#pandastools.abc.abstracts.AbstractPtDataFrame","title":"<code>AbstractPtDataFrame</code>","text":"<p>         Bases: <code>ABC</code>, <code>AsyncIterator</code>, <code>Awaitable</code>, <code>Sized</code>, <code>Iterator</code></p> <p>Abstract base class for DataFrame objects.</p> Source code in <code>pandastools\\abc\\abstracts.py</code> <pre><code>class AbstractPtDataFrame(ABC, AsyncIterator, Awaitable, Sized, Iterator):\n\"\"\"Abstract base class for DataFrame objects.\"\"\"\n@abstractmethod\ndef __repr__(self):\n...\n@abstractmethod\ndef __str__(self):\n...\n@abstractmethod\ndef __enter__(self):\n...\n@abstractmethod\nasync def __aenter__(self):\n...\n@abstractmethod\ndef __exit__(self, exc_type, exc_val, exc_tb):\n...\n@abstractmethod\nasync def __aexit__(self, exc_type, exc_val, exc_tb):\n...\n</code></pre>"},{"location":"core/dataframe/","title":"dataframe","text":""},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame","title":"<code>PtDataFrame</code>","text":"<p>         Bases: <code>AbstractPtDataFrame</code></p> <p>A class representing a Pandas DataFrame with additional functionality.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.</p> <code>pd.DataFrame()</code> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>class PtDataFrame(AbstractPtDataFrame):\n\"\"\"\n    A class representing a Pandas DataFrame with additional functionality.\n    Args:\n        df (pd.DataFrame, optional): The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.\n    \"\"\"\ndef __init__(self, df: pd.DataFrame = pd.DataFrame()) -&gt; None:\n\"\"\"\n        Initialize the PtDataFrame.\n        Args:\n            df (pd.DataFrame, optional): The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.\n        \"\"\"\nself._df = df\nself._iterator = self._df.itertuples(index=False)\nself._lock = Lock()\n@property\ndef df(self) -&gt; pd.DataFrame:\n\"\"\"\n        Get the encapsulated Pandas DataFrame.\n        Returns:\n            pd.DataFrame: The encapsulated Pandas DataFrame.\n        \"\"\"\nreturn self._df\ndef __repr__(self) -&gt; str:\n\"\"\"\n        Return a string representation of the PtDataFrame.\n        Returns:\n            str: A string representation of the PtDataFrame.\n        \"\"\"\nreturn self._df.__repr__()\ndef __str__(self) -&gt; str:\n\"\"\"\n        Return a string representation of the PtDataFrame.\n        Returns:\n            str: A string representation of the PtDataFrame.\n        \"\"\"\nreturn self._df.__str__()\ndef __await__(self) -&gt; Awaitable:\n\"\"\"\n        Awaitable support for the PtDataFrame.\n        Returns:\n            Awaitable: An awaitable object.\n        \"\"\"\nreturn sleep(0.0001).__await__()\ndef __enter__(self) -&gt; pd.DataFrame:\n\"\"\"\n        Enter the context manager and return the encapsulated Pandas DataFrame.\n        Returns:\n            pd.DataFrame: The encapsulated Pandas DataFrame.\n        \"\"\"\nreturn self._df\nasync def __aenter__(self) -&gt; pd.DataFrame:\n\"\"\"\n        Asynchronous version of __enter__(). Enter the context manager and return the encapsulated Pandas DataFrame.\n        Returns:\n            pd.DataFrame: The encapsulated Pandas DataFrame.\n        \"\"\"\nreturn self._df\ndef __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n\"\"\"\n        Exit the context manager.\n        Args:\n            exc_type (type): The exception type, if any.\n            exc_val (Exception): The exception instance, if any.\n            exc_tb (traceback): The traceback, if any.\n        \"\"\"\nreturn None\nasync def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n\"\"\"\n        Asynchronous version of __exit__(). Exit the context manager.\n        Args:\n            exc_type (type): The exception type, if any.\n            exc_val (Exception): The exception instance, if any.\n            exc_tb (traceback): The traceback, if any.\n        \"\"\"\nreturn None\ndef __aiter__(self) -&gt; Iterator:\n\"\"\"\n        Asynchronous iterator support for the PtDataFrame.\n        Returns:\n            Iterator: An asynchronous iterator.\n        \"\"\"\nself._iterator = self._df.itertuples(index=False)\nasync def _aiter() -&gt; Iterator:\n\"\"\"\n            Asynchronous iterator helper function.\n            Yields:\n                Iterator: An item from the PtDataFrame.\n            \"\"\"\nwhile True:\ntry:\nyield self._iterator.__next__()\nexcept StopIteration:\nbreak\nreturn _aiter()\ndef __iter__(self) -&gt; Iterator:\n\"\"\"\n               Iterator\n        support for the PtDataFrame.\n               Returns:\n                   Iterator: An iterator.\n        \"\"\"\nself._iterator = self._df.itertuples(index=False)\nreturn (it for it in self._iterator)\ndef __len__(self) -&gt; int:\n\"\"\"\n        Return the length of the PtDataFrame.\n        Returns:\n            int: The length of the PtDataFrame.\n        \"\"\"\nreturn len(self._df)\nasync def __anext__(self) -&gt; Awaitable:\n\"\"\"\n        Asynchronous iterator support for the PtDataFrame.\n        Returns:\n            Awaitable: An awaitable object.\n        \"\"\"\nasync with self._lock:\ntry:\nreturn self._iterator.__next__()\nexcept StopIteration:\nraise StopAsyncIteration\ndef __next__(self):\n\"\"\"\n        Iterator support for the PtDataFrame.\n        Returns:\n            Any: An item from the PtDataFrame.\n        \"\"\"\nreturn self._iterator.__next__()\ndef __add__(self, other):\n\"\"\"\n        Concatenate the PtDataFrame with another PtDataFrame.\n        Args:\n            other (PtDataFrame): The PtDataFrame to concatenate.\n        Returns:\n            PtDataFrame: The concatenated PtDataFrame.\n        \"\"\"\nconcat = pd.concat([self._df, other._df], ignore_index=True)\nreturn PtDataFrame(concat)\ndef __iadd__(self, other):\n\"\"\"\n        In-place concatenation of the PtDataFrame with another PtDataFrame.\n        Args:\n            other (PtDataFrame): The PtDataFrame to concatenate.\n        Returns:\n            PtDataFrame: The concatenated PtDataFrame.\n        \"\"\"\nself._df = pd.concat([self._df, other._df], ignore_index=True)\nreturn self\n@classmethod\ndef reduce(cls, df_list):\n\"\"\"\n        Reduce a list of PtDataFrame objects into a single PtDataFrame.\n        Args:\n            df_list (List[PtDataFrame]): The list of PtDataFrame objects to reduce.\n        Returns:\n            PtDataFrame: The reduced PtDataFrame.\n        \"\"\"\nreturn PtDataFrame(reduce(lambda x, y: x + y, df_list).df)\ndef col_to_list(self, col_name, drop_duplicates=True):\n\"\"\"\n        Extract a column as a list from the PtDataFrame.\n        Args:\n            col_name (str): The name of the column to extract.\n            drop_duplicates (bool, optional): Whether to drop duplicate values. Defaults to True.\n        Returns:\n            List: The column values as a list.\n        \"\"\"\nif drop_duplicates:\nreturn self._df[col_name].drop_duplicates().tolist()\nreturn self._df[col_name].tolist()\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.df","title":"<code>df: pd.DataFrame</code>  <code>property</code>","text":"<p>Get the encapsulated Pandas DataFrame.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: The encapsulated Pandas DataFrame.</p>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Concatenate the PtDataFrame with another PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PtDataFrame</code> <p>The PtDataFrame to concatenate.</p> required <p>Returns:</p> Name Type Description <code>PtDataFrame</code> <p>The concatenated PtDataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __add__(self, other):\n\"\"\"\n    Concatenate the PtDataFrame with another PtDataFrame.\n    Args:\n        other (PtDataFrame): The PtDataFrame to concatenate.\n    Returns:\n        PtDataFrame: The concatenated PtDataFrame.\n    \"\"\"\nconcat = pd.concat([self._df, other._df], ignore_index=True)\nreturn PtDataFrame(concat)\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Asynchronous version of enter(). Enter the context manager and return the encapsulated Pandas DataFrame.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: The encapsulated Pandas DataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>async def __aenter__(self) -&gt; pd.DataFrame:\n\"\"\"\n    Asynchronous version of __enter__(). Enter the context manager and return the encapsulated Pandas DataFrame.\n    Returns:\n        pd.DataFrame: The encapsulated Pandas DataFrame.\n    \"\"\"\nreturn self._df\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Asynchronous version of exit(). Exit the context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>The exception type, if any.</p> required <code>exc_val</code> <code>Exception</code> <p>The exception instance, if any.</p> required <code>exc_tb</code> <code>traceback</code> <p>The traceback, if any.</p> required Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n\"\"\"\n    Asynchronous version of __exit__(). Exit the context manager.\n    Args:\n        exc_type (type): The exception type, if any.\n        exc_val (Exception): The exception instance, if any.\n        exc_tb (traceback): The traceback, if any.\n    \"\"\"\nreturn None\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__aiter__","title":"<code>__aiter__()</code>","text":"<p>Asynchronous iterator support for the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>Iterator</code> <code>Iterator</code> <p>An asynchronous iterator.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __aiter__(self) -&gt; Iterator:\n\"\"\"\n    Asynchronous iterator support for the PtDataFrame.\n    Returns:\n        Iterator: An asynchronous iterator.\n    \"\"\"\nself._iterator = self._df.itertuples(index=False)\nasync def _aiter() -&gt; Iterator:\n\"\"\"\n        Asynchronous iterator helper function.\n        Yields:\n            Iterator: An item from the PtDataFrame.\n        \"\"\"\nwhile True:\ntry:\nyield self._iterator.__next__()\nexcept StopIteration:\nbreak\nreturn _aiter()\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Asynchronous iterator support for the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>Awaitable</code> <code>Awaitable</code> <p>An awaitable object.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>async def __anext__(self) -&gt; Awaitable:\n\"\"\"\n    Asynchronous iterator support for the PtDataFrame.\n    Returns:\n        Awaitable: An awaitable object.\n    \"\"\"\nasync with self._lock:\ntry:\nreturn self._iterator.__next__()\nexcept StopIteration:\nraise StopAsyncIteration\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__await__","title":"<code>__await__()</code>","text":"<p>Awaitable support for the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>Awaitable</code> <code>Awaitable</code> <p>An awaitable object.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __await__(self) -&gt; Awaitable:\n\"\"\"\n    Awaitable support for the PtDataFrame.\n    Returns:\n        Awaitable: An awaitable object.\n    \"\"\"\nreturn sleep(0.0001).__await__()\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager and return the encapsulated Pandas DataFrame.</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: The encapsulated Pandas DataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __enter__(self) -&gt; pd.DataFrame:\n\"\"\"\n    Enter the context manager and return the encapsulated Pandas DataFrame.\n    Returns:\n        pd.DataFrame: The encapsulated Pandas DataFrame.\n    \"\"\"\nreturn self._df\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>The exception type, if any.</p> required <code>exc_val</code> <code>Exception</code> <p>The exception instance, if any.</p> required <code>exc_tb</code> <code>traceback</code> <p>The traceback, if any.</p> required Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n\"\"\"\n    Exit the context manager.\n    Args:\n        exc_type (type): The exception type, if any.\n        exc_val (Exception): The exception instance, if any.\n        exc_tb (traceback): The traceback, if any.\n    \"\"\"\nreturn None\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>In-place concatenation of the PtDataFrame with another PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PtDataFrame</code> <p>The PtDataFrame to concatenate.</p> required <p>Returns:</p> Name Type Description <code>PtDataFrame</code> <p>The concatenated PtDataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __iadd__(self, other):\n\"\"\"\n    In-place concatenation of the PtDataFrame with another PtDataFrame.\n    Args:\n        other (PtDataFrame): The PtDataFrame to concatenate.\n    Returns:\n        PtDataFrame: The concatenated PtDataFrame.\n    \"\"\"\nself._df = pd.concat([self._df, other._df], ignore_index=True)\nreturn self\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__init__","title":"<code>__init__(df=pd.DataFrame())</code>","text":"<p>Initialize the PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.</p> <code>pd.DataFrame()</code> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __init__(self, df: pd.DataFrame = pd.DataFrame()) -&gt; None:\n\"\"\"\n    Initialize the PtDataFrame.\n    Args:\n        df (pd.DataFrame, optional): The Pandas DataFrame to be encapsulated. Defaults to an empty DataFrame.\n    \"\"\"\nself._df = df\nself._iterator = self._df.itertuples(index=False)\nself._lock = Lock()\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__iter__","title":"<code>__iter__()</code>","text":"<pre><code>   Iterator\n</code></pre> <p>support for the PtDataFrame.</p> <pre><code>   Returns:\n       Iterator: An iterator.\n</code></pre> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __iter__(self) -&gt; Iterator:\n\"\"\"\n           Iterator\n    support for the PtDataFrame.\n           Returns:\n               Iterator: An iterator.\n    \"\"\"\nself._iterator = self._df.itertuples(index=False)\nreturn (it for it in self._iterator)\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__len__","title":"<code>__len__()</code>","text":"<p>Return the length of the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The length of the PtDataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Return the length of the PtDataFrame.\n    Returns:\n        int: The length of the PtDataFrame.\n    \"\"\"\nreturn len(self._df)\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__next__","title":"<code>__next__()</code>","text":"<p>Iterator support for the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>Any</code> <p>An item from the PtDataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __next__(self):\n\"\"\"\n    Iterator support for the PtDataFrame.\n    Returns:\n        Any: An item from the PtDataFrame.\n    \"\"\"\nreturn self._iterator.__next__()\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PtDataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Return a string representation of the PtDataFrame.\n    Returns:\n        str: A string representation of the PtDataFrame.\n    \"\"\"\nreturn self._df.__repr__()\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the PtDataFrame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the PtDataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Return a string representation of the PtDataFrame.\n    Returns:\n        str: A string representation of the PtDataFrame.\n    \"\"\"\nreturn self._df.__str__()\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.col_to_list","title":"<code>col_to_list(col_name, drop_duplicates=True)</code>","text":"<p>Extract a column as a list from the PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>The name of the column to extract.</p> required <code>drop_duplicates</code> <code>bool</code> <p>Whether to drop duplicate values. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>List</code> <p>The column values as a list.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>def col_to_list(self, col_name, drop_duplicates=True):\n\"\"\"\n    Extract a column as a list from the PtDataFrame.\n    Args:\n        col_name (str): The name of the column to extract.\n        drop_duplicates (bool, optional): Whether to drop duplicate values. Defaults to True.\n    Returns:\n        List: The column values as a list.\n    \"\"\"\nif drop_duplicates:\nreturn self._df[col_name].drop_duplicates().tolist()\nreturn self._df[col_name].tolist()\n</code></pre>"},{"location":"core/dataframe/#pandastools.core.dataframe.PtDataFrame.reduce","title":"<code>reduce(df_list)</code>  <code>classmethod</code>","text":"<p>Reduce a list of PtDataFrame objects into a single PtDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df_list</code> <code>List[PtDataFrame]</code> <p>The list of PtDataFrame objects to reduce.</p> required <p>Returns:</p> Name Type Description <code>PtDataFrame</code> <p>The reduced PtDataFrame.</p> Source code in <code>pandastools\\core\\dataframe.py</code> <pre><code>@classmethod\ndef reduce(cls, df_list):\n\"\"\"\n    Reduce a list of PtDataFrame objects into a single PtDataFrame.\n    Args:\n        df_list (List[PtDataFrame]): The list of PtDataFrame objects to reduce.\n    Returns:\n        PtDataFrame: The reduced PtDataFrame.\n    \"\"\"\nreturn PtDataFrame(reduce(lambda x, y: x + y, df_list).df)\n</code></pre>"},{"location":"getting_started/quickstart/","title":"Quick Start","text":""},{"location":"getting_started/quickstart/#usage","title":"Usage","text":"<p>Here's an example of how to use the <code>PtDataFrame</code> class:</p> <pre><code>import pandas as pd\nfrom pandastools.core.dataframe import PtDataFrame\n# Create a Pandas DataFrame\ndata = {\n\"a\": [1, 2, 3],\n\"b\": [4, 5, 6],\n\"c\": [7, 8, 9]\n}\ndf = pd.DataFrame(data)\n# Create a PtDataFrame from the Pandas DataFrame\npt_df = PtDataFrame(df)\n# Async Iterate over rows\nasync for row in pt_df:\nprint(row)\n# Concatenate PtDataFrames\npt_df2 = PtDataFrame(df)\nconcatenated = pt_df + pt_df2\n# Reduce a list of PtDataFrames\npt_df3 = PtDataFrame.reduce([pt_df, pt_df2])\n# Extract a column as a list\ncol_values = pt_df.col_to_list(\"a\")\nprint(col_values)\n</code></pre>"}]}